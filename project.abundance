{
    "atomType": "Molecule",
    "x": 0,
    "y": 0,
    "uniqueID": "id-1005",
    "name": "Get-Width",
    "ioValues": [
        {
            "name": "InputShape",
            "ioValue": "__GEOMETRY_INPUT__"
        }
    ],
    "topLevel": true,
    "allAtoms": [
        {
            "atomType": "Output",
            "x": 0.98,
            "y": 0.5,
            "uniqueID": "id-1006",
            "ioValues": [
                {
                    "name": "number or geometry",
                    "ioValue": "__GEOMETRY_INPUT__"
                }
            ]
        },
        {
            "atomType": "Input",
            "x": 0.031349999999999996,
            "y": 0.3413897280966767,
            "uniqueID": "id-1008",
            "name": "InputShape",
            "type": "geometry"
        },
        {
            "atomType": "Code",
            "x": 0.4400656814449918,
            "y": 0.5649546827794562,
            "uniqueID": "id-1011",
            "ioValues": [
                {
                    "name": "shape",
                    "ioValue": "__GEOMETRY_INPUT__"
                }
            ],
            "codeVersion": 1,
            "code": "\n// Example Code\nconst Inputs = [\n  { inputName: \"shape\", type: \"geometry\", defaultValue: null },\n];\n\n\nlet importedShape = library[shape];\nconsole.log(importedShape)\n\nfunction extractBox(boxObj) {\n  if (!boxObj) return null;\n  // If bounds is an array of two arrays\n  if (\n    Array.isArray(boxObj.bounds) &&\n    boxObj.bounds.length === 2 &&\n    Array.isArray(boxObj.bounds[0]) &&\n    Array.isArray(boxObj.bounds[1])\n  ) {\n    const [min, max] = boxObj.bounds;\n    // 2D: [minX, minY, minZ, maxX, maxY, maxZ]\n    return [min[0], min[1], 0, max[0], max[1], 0];\n  }\n  // If _wrapped has a bounds property\n  if (\n    boxObj._wrapped &&\n    Array.isArray(boxObj._wrapped.bounds) &&\n    boxObj._wrapped.bounds.length === 2 &&\n    Array.isArray(boxObj._wrapped.bounds[0]) &&\n    Array.isArray(boxObj._wrapped.bounds[1])\n  ) {\n    const [min, max] = boxObj._wrapped.bounds;\n    return [min[0], min[1], 0, max[0], max[1], 0];\n  }\n  return null;\n}\n\nfunction getBoundingBox(obj) {\n  const visited = new Set();\n\n  function mergeBoxes(a, b) {\n    if (!a) return b;\n    if (!b) return a;\n    return [\n      Math.min(a[0], b[0]),\n      Math.min(a[1], b[1]),\n      Math.min(a[2], b[2]),\n      Math.max(a[3], b[3]),\n      Math.max(a[4], b[4]),\n      Math.max(a[5], b[5]),\n    ];\n  }\n\n  function recurse(val) {\n    if (!val || typeof val !== \"object\") return null;\n    if (visited.has(val)) return null;\n    visited.add(val);\n\n    // Try to extract bounding box from _boundingBox or boundingBox\n    let box = extractBox(val._boundingBox) || extractBox(val.boundingBox);\n    // Only recurse into geometry arrays\n    if (Array.isArray(val.geometry)) {\n      box = val.geometry.reduce(\n        (acc, item) => mergeBoxes(acc, recurse(item)),\n        box\n      );\n    }\n    // If this is an array, recurse into each item\n    if (Array.isArray(val)) {\n      box = val.reduce((acc, item) => mergeBoxes(acc, recurse(item)), box);\n    }\n    return box;\n  }\n\n  return recurse(obj);\n}\n\nfunction getBoundingBoxSize(bbox) {\n  if (!Array.isArray(bbox) || bbox.length < 6) return null;\n  const width = bbox[3] - bbox[0];\n  const height = bbox[4] - bbox[1];\n  return { width, height };\n}\n\nconst boundingBox= getBoundingBox(importedShape)\nconsole.log(boundingBox)\nconst boundingBoxSize= getBoundingBoxSize(boundingBox)\nconsole.log(boundingBoxSize)\n\n//let assembly = await Assembly([importedShape, cylObj]);\nreturn boundingBoxSize.width.toString()\n"
        },
        {
            "atomType": "Circle",
            "x": 0.2602627257799672,
            "y": 0.22960725075528698,
            "uniqueID": "id-1016",
            "ioValues": [
                {
                    "name": "diameter",
                    "ioValue": 10
                }
            ]
        },
        {
            "atomType": "Text",
            "x": 0.7183908045977012,
            "y": 0.2688821752265861,
            "uniqueID": "id-1023",
            "ioValues": [
                {
                    "name": "Font Size",
                    "ioValue": 10
                }
            ],
            "fontFamily": "ANTON",
            "selectedFontIndex": 0
        },
        {
            "atomType": "Readme",
            "x": 0.5944170771756978,
            "y": 0.7039274924471299,
            "uniqueID": "id-1027",
            "name": "README",
            "ioValues": [
                {
                    "name": "geometry",
                    "ioValue": "__GEOMETRY_INPUT__"
                }
            ],
            "readMeText": "Readme text here",
            "global": true
        }
    ],
    "allConnectors": [
        {
            "ap2Name": "shape",
            "ap1ID": "id-1008",
            "ap2ID": "id-1011"
        },
        {
            "ap2Name": "Text",
            "ap1ID": "id-1011",
            "ap2ID": "id-1023"
        },
        {
            "ap2Name": "number or geometry",
            "ap1ID": "id-1023",
            "ap2ID": "id-1006"
        }
    ],
    "unitsKey": "Unitless",
    "fileTypeVersion": 1,
    "filetypeVersion": 1
}